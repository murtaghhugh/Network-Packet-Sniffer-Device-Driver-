#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/init.h>
#include <linux/netfilter.h>
#include <linux/netfilter_ipv4.h>
#include <linux/ip.h>
#include <linux/tcp.h>
#include <linux/udp.h>
#include <linux/proc_fs.h>

MODULE_LICENSE("GPL");
MODULE_AUTHOR("Your Name");
MODULE_DESCRIPTION("A simple packet sniffer kernel module");
MODULE_VERSION("1.0");

#define PROC_NAME "netlogger"
static struct nf_hook_ops netfilter_hook;
static struct proc_dir_entry *proc_entry;
static char log_buffer[4096];
static int log_pos = 0;

/* Packet Sniffer Function */
static unsigned int packet_sniffer(void *priv, struct sk_buff *skb,
                                   const struct nf_hook_state *state) {
    struct iphdr *ip_header;
    struct tcphdr *tcp_header;
    struct udphdr *udp_header;
    char log_entry[256];

    if (!skb)
        return NF_ACCEPT;

    ip_header = ip_hdr(skb);
    if (!ip_header)
        return NF_ACCEPT;

    snprintf(log_entry, sizeof(log_entry),
             "Packet: SRC=%pI4 DST=%pI4 PROTO=%d\n",
             &ip_header->saddr, &ip_header->daddr, ip_header->protocol);

    if (ip_header->protocol == IPPROTO_TCP) {
        tcp_header = tcp_hdr(skb);
        snprintf(log_entry + strlen(log_entry), sizeof(log_entry) - strlen(log_entry),
                 " TCP SRC_PORT=%u DST_PORT=%u\n",
                 ntohs(tcp_header->source), ntohs(tcp_header->dest));
    } else if (ip_header->protocol == IPPROTO_UDP) {
        udp_header = udp_hdr(skb);
        snprintf(log_entry + strlen(log_entry), sizeof(log_entry) - strlen(log_entry),
                 " UDP SRC_PORT=%u DST_PORT=%u\n",
                 ntohs(udp_header->source), ntohs(udp_header->dest));
    }

    /* Save log entry to buffer */
    if (log_pos + strlen(log_entry) < sizeof(log_buffer)) {
        strcat(log_buffer, log_entry);
        log_pos += strlen(log_entry);
    }

    return NF_ACCEPT;
}

/* Proc File Read */
static ssize_t netlogger_read(struct file *file, char __user *user_buffer,
                              size_t count, loff_t *pos) {
    return simple_read_from_buffer(user_buffer, count, pos, log_buffer, log_pos);
}

static const struct proc_ops proc_fops = {
    .proc_read = netlogger_read,
};

/* Module Init */
static int __init my_module_init(void) {
    printk(KERN_INFO "Packet Sniffer: Module loaded.\n");

    /* Register Netfilter Hook */
    netfilter_hook.hook = packet_sniffer;
    netfilter_hook.hooknum = NF_INET_PRE_ROUTING;
    netfilter_hook.pf = PF_INET;
    netfilter_hook.priority = NF_IP_PRI_FIRST;
    nf_register_net_hook(&init_net, &netfilter_hook);

    /* Create /proc file */
    proc_entry = proc_create(PROC_NAME, 0666, NULL, &proc_fops);
    if (!proc_entry) {
        nf_unregister_net_hook(&init_net, &netfilter_hook);
        return -ENOMEM;
    }
    return 0;
}

/* Module Exit */
static void __exit my_module_exit(void) {
    nf_unregister_net_hook(&init_net, &netfilter_hook);
    proc_remove(proc_entry);
    printk(KERN_INFO "Packet Sniffer: Module unloaded.\n");
}

module_init(my_module_init);
module_exit(my_module_exit);
